
\maketitle
|tikz|\tableofcontents

# Définitions

## Les grammaires formelles

Une grammaire formelle est un quadruplet $G = (T,N_t,S,D)$ où :

---i
#### $T$ est l'alphabet des terminaux
#### $N_t$ est l'alphabet des non terminaux
#### $S \in N_t$ est l'axiome

Notons $\Sigma := N_t \cup T0$
#### $D \subset (\Sigma ^ \star )^2$, est l'ensemble des règles de dérivation.
---i
Pour $(a,b) \in D$, soit $\overset{(a,b)}{\->}$ la relation binaire définie sur $\Sigma^\star$ par
!equu!
\forall m,m' \in \Sigma^\star, m \overset{(a,b)}{\->} m' \iff \exists u,v \in \Sigma^\star / m = uav \text{ et } m' = ubv
!equu!
On note $\-> := \bigcup_{d \in D} \overset{d}{\->}$ et on note $\overset{*}{\->}$ la cloture transitive et réflexive de $\->$.\\
Pour $x \in (\Sigma)^\star$, notons\\
$\delta(x) := \{y \in (\Sigma)^\star / x \overset{*}{\->} y\}$\\
$\eta(x) := \delta(x) \cap T^\star$\\
$\norm{x}_l := \norm{\{i \in \mathbb{N} \mid x_i = l \}}$ est le nombre d'occurences de la lettre $l$ dans x.

Alors le langage de la grammaire formelle  G est le suivant :
!equu!\mathcal{L} (G) := \eta(S)!equu!

Nous allons supposer que $N_t$ est dénombrable et $T$ est fini.

|code|En OCaml :
|code|---code
|code|type 'e caractere = T of 'e | Nt of int

|code|type 'a regle = ('a array) * ('a array)

|code|type 'e fg = {
|code|  terminaux : ('e caractere) array ;
|code|  nonterminaux : ('e caractere) array ;
|code|  axiome : 'e caractere ;
|code|  reglesf : ('e caractere) regle array
|code|} 
|code|---code
## Les grammaires non contextuelle

!b Définition :! Une grammaire non contextuelle est une grammaire $G = (T,N_t,S,D)$ telle que :
!equu! \forall (a,b) \in D, a \in N_t  !equu!
(Nous identifions les mots de longueur 1 et les lettres)

|code|---code
|code|type 'a reglecf = int * ('a array)

|code|type 'e cfg = {
|code|  terminaux : ('e caractere) array ;
|code|  nonterminaux : ('e caractere) array ;
|code|  axiome : 'e caractere ;
|code|  reglescf : ('e caractere) reglecf array
|code|}
|code|---code

|code|!bExemple :! la grammaire non contextuelle des expressions arithmétiques suffixes.
|code|---ml
|code|D = &\{(!sS!,!sSS+!)_1,(!sS!,!sSS*!)_2,(!sS!,!s"N"!)_3\}\\
|code|\cup&\{(!sN!,!sC!)_4 | (!sN!,!sNC!)_5\}\\
|code|\cup&\{(!sC!,!s0!)_6 | (!sC!,!s 1!)_7\}
|code|---ml
|code|(les indices ci-dessus correspondent à une énumération des règles de dérivation, par exemple, $D_5 = (!sN!,!sNC!)$)

## Fôret de dérivation

Ici, $G = (T,N_t,S,D)$ est une grammaire non contextuelle.

Une forêt est une liste d'arbres
|code|---code
|code|type 'a arbre = 'a * 'a foret 
|code|and 'a foret = F of 'a arbre list
|code|---code


Une preuve qu'un mot appartient à $\eta(m)$ peut être donnée par une forêt de dérivation de $m$:

---t
Si $m$ est le mot vide, il s'agit de la forêt vide.

Sinon, soit $n = \norm{m}$,\\
---t
    Si $n=1$ et $m_0 \in T$,il s'agit d'un seul arbre où la racine est $m$ et la sous forêt est la forêt de dérivation d'un $b$ tel que $(m,b) \in D$.

    Si $n=1$ et $m_0 \in N_t$, il s'agit de l'arbre de racine m et de sous forêt vide.

    Si $n>1$, il s'agit de la liste des arbres $[f_1, \dots, f_n]$ où $\forall i \in [1,n], f_i$ est un arbre de dérivation de la lettre $m_i$.
---tf
---tf
|code|
|code|D'où la fonction OCaml suivante :
|code|
|code|---code
|code|let rec test_foret_deriv foret mot regles =
|code|  let n = List.length mot in
|code|  if n = 0 then foret = F [] else
|code|  match foret with
|code|      |(F sousarbres) ->
|code|          if (List.length sousarbres) <> n then false else
|code|          List.for_all2
|code|          (fun arb lettre ->
|code|              test_arbre_deriv arb regles
|code|          )
|code|          sousarbres
|code|          mot
|code|and test_arbre_deriv arb regles =
|code|  let (lettre,sousforet) = arb in
|code|  match lettre with
|code|      |T x -> arb = (T x,F [])
|code|      |Nt i ->
|code|          let nouveaumot = lisracines sousforet in
|code|          (List.mem (i,nouveaumot) regles)&&
|code|          (test_foret_deriv sousforet nouveaumot regles)
|code|---code

L'ensemble des forêts de dérivation de $m$ est noté $\mathcal{F}(m)$.\\
Le parcours infixe des feuilles d'une forêt de dérivation de $x$ donne un mot de $\eta(x)$.
|code|Un exemple sera donnée dans le cas d'une grammaire non contextuelle.\\
Pour $a \in \mathcal{F}(x)$, on note $\mathcal{I}(a)$ le parcours infixe des feuilles de $a$. 

|code|## Exemple de preuve

|code|Une preuve que !s"10""11"+"0"*! $\in \mathcal{L}(G)$ :\\
|code|Lemme 1 : !s"10"! $\in \eta(S)$

|code|    En effet, $!sS!\->_3 !s"N"! \->_5 !s"NC"! \->_6 !s"N0"! \->_4 !s"C0"! \->_7 !s"10"!$


|code|L'abre de dérivation fait aussi office de preuve, bien plus concise :
|code||tikz|   !ftree1.tikz!

|code|Lemme 2 : !s"11"! $\in \eta(S)$
|code|Preuve avec l'arbre suivant
|code||tikz| !ftree2.tikz!

|code|On peut alors, en combinant les deux arbres précédants, prouver que !s"10""11"+! $\in \eta(S)$ :
|code||tikz| !ftree3.tikz!

|code|Avec l'arbre suivant, on prouve enfin que !s"10""11"+"0"*! $\in \delta(S) \cap T^\star = \mathcal{L}(G)$ :
|code||tikz| !ftree4.tikz!

|code|On remarque bien qu'un parcours infixe des feuilles de l'arbre donne !s"10""11"+"0"*!

# Vérification de preuve - grammaire non contextuelle

La forêt de dérivation nous donne une bonne manière de vérifier une preuve, car une preuve est caractérisé par une forêt de dérivation.\\

Par induction on peut montrer $m \in \eta(x) \implies $ il existe $p$ une forêt de dérivation dont le parcours infixe des feuilles est $m$ et les racines sont les lettres de $x$.

|code|!nb$A_{[p,q]}$ correspond à la forêt $A$ restreinte à ses arbres d'indice $i / p\leq i \leq q$ et $A@B$ correspond à la concaténation des forêts $A$ et $B$. !

|code|---t
|code|$
|code|m \in \eta(x)\\
|code|\iff \exists n \in \mathbb{N} / \exists m_1,m_2,\dots,m_n \in \Sigma^\star / x \-> m_1 \-> m_2 \-> \dots \-> m_n\text{ et }m_n \in T^\star$    $ (2_n)\\
|code|\mathcal{P}(n) := ((2_n) \implies \exists A \in \mathcal{F}(x) / \mathcal{I}(x) = m)$\\
|code|---t
|code|$\mathcal{P}(0) : x \in \eta(x) \implies x \in T^\star$ donc $[B (x_1);\dots;B (x_{\norm{x}})]$ convient.\\
|code|$\forall n \in \mathbb{N}^*,\mathcal{P}(n-1) \implies (m \in \eta(m_1) \implies \exists A \in \mathcal{F}(m_1)/ \mathcal{I}(A) = m)$

|code| et comme $x\-> m_1,\exists (a,b) \in D, u,v\in \Sigma^\star /x = uav$ et $m_1 = ubv$

|code| Soit $p := \norm{u}, q := \norm{v}, r := \norm{b}$
 
|code| alors $A|_{[1,p]} \in \mathcal{F}(u), A|_{[p+1,p+r]} \in \mathcal{F}(b), A|_{[p+r+1,p+r+q]} \in \mathcal{F}(v)$

|code| Donc $A|_{[1,p]}@A'@A|_{[p+r+1,p+r+q]}\in \mathcal{F}(x)$ où $A' = N (b,A|_{[p+1,p+r]})$

|code| Soit $\mathcal{P}(n)$.
|code|---tf
|code|---tf
La réciproque se montre avec un algorithme qui à un arbre de dérivation associe une séquence $m_1,m_2,\dots,m_n \in \Sigma^\star$ telle que $x \-> m_1 \-> m_2 \-> \dots \-> m_n$

|code|En entrée, nous avons $f_0$, une forêt de dérivation.
|code|---t
|code|$f$ est une copie de $f_0$. 

|code|Tant que $f$ n'est pas constituée que de feuilles :

|code|---t
|code|    On prend $a$ un arbre qui n'est pas une feuille dans $f$

|code|    Remplacer $a$, dans $f$, par ses fils.

|code|    Lire les racines de la forêt de gauche à droite.
|code|---tf
|code|---tf
|code|En remplaçant $a$ dans $f$ par ses fils, on dérive notre mot une fois.\\\\

\fbox{Alors $a \in \mathcal{F}(S)$ est une preuve que $\mathcal{I}(a) \in \mathcal{L}(G)$.}

Alors, vérifier une preuve donnée par une forêt consiste simplement à vérifier que la forêt est bien une forêt de dérivation.

# Preuve automatique - grammaire non contextuelle

Toujours dans une grammaire non contextuelle

Avec une grammaire dont l'axiome est S,
pour générer automatiquement une preuve, l'idée est qu'à chaque étape,
on dispose d'une liste de mots prouvés,
et on fait toutes les dérivations possibles de notre liste de mots prouvés pour obtenir une liste de mots prouvés plus grande.

Deux approches coexistent alors, soit on fait toutes les dérivations possibles dans le sens direct, soit dans le sens indirect.

## La méthode bottom-up

On part des $\\{ [(b_1,[]);\dots;(b_n,[])] \mid (a,b)\in D \text{ et } b \in T^\star , n = \norm{b}\\}$ et on construit d'autres arbres de dérivation à partir des règles de dérivation.

|code|Par la méthode bottom-up, on générerait dans l'ordre :\\
|code|à l'étape 0 :
|code||tikz| !ftbu0.tikz!
|code|à l'étape 1 : 
|code||tikz| !ftbu1.tikz!
|code|à l'étape 2 : 
|code||tikz| !ftbu2.tikz!
|code|à l'étape 3 : 
|code||tikz| !ftbu3.tikz!

On prouve par induction simple qu'à l'étape $k$, on a généré tous les arbres de dérivations possibles de profondeur $\leq k$.

## La méthode top-down

On part de l'axiome $S$ de la grammaire non contextuelle pour construire des mots de $\delta(S)$ en remplaçant un nonterminal $x$ d'un mot par un $b$ d'une règle de dérivation $(x,b)$.

Cette méthode suit d'assez près la définition des mots de la grammaire non contextuelle\\
On génère en effet, avec cette méthode, à la $n$-ième étape, 

$A_n = \\{m \in \Sigma^\star \mid  S \(\bigcup_{k \in [1,n]} \->^k\) m\\}$\\
Il est alors simple de vérifier que tout mot du langage de la grammaire sera généré en temps fini par cette méthode.

|code|On génère alors dans l'ordre :\\
|code|à l'étape 0 : $\{S\}$, \\
|code|à l'étape 1 : $\{S,SS+,SS*,"N"\}$,\\
|code|et à l'étape 2 : $\{S,SS+,SS*,"N",SS*S+,SSS*+,SSS+*,SS+S*,$ \\
|code|$"N"S+,S"N"+,"N"S*,S"N"*,"C","NC"\}$.

Cette méthode est bien plus proche de la définition et est directement applicable aux grammaire formelles.

# Vérification de preuve - grammaire formelle

## Une nouvelle structure de données pour les preuves

Nous ne disposons plus des forêts de dérivation. Alors nous pouvons nous restreindre à la définition d'un mot qui dérive d'un autre.
On va alors fournir, comme preuve, une liste de mots $m_1, \dots, m_n$ tels que $\forall i\in [1,n-1], m_i \-> m_{i+1}$. 
Pour ceci nous allons renseigner de quelle manière le mot $m_{i+1}$ dérive du mot $m_i$ par la règle de dérivation $(a,b)$, par exemple en fournissant les indices délimitant $a$ dans $m_i$, et $b$ le remplaçant.
Nous aboutissons alors à :
---code
type 'e preuveformelle = (int*int*('e caractere list)) list
---code

|code|Nous prendrons comme exemple la grammaire formelle $G = (T,N_t,S,D)$ où :\\
|code|$
|code|T = \{!sa!,!sb!,!sc!\}\\
|code|N_t = \{!sS!,!sB!\}\\
|code|D = \{(!sS!,!saBSc!)_1,(!sS!,!sabc!)_2,(!sBa!,!saB!)_3,(!sBb!,!sbb!)_4\}
|code|$,\\
|code|alors !saabbcc! est dans $\mathcal{L}(G)$ car $!sS! \->_1 !saBSc! \->_2 !saBabcc! \->_3 !saaBbcc! \->_4 !saabbcc!$.\\
|code|En Ocaml :
|code|---code
|code|let unepreuve = [(0,1,mot "aBSc");(2,3,mot "abc");(1,3,mot "aB");(2,4,mot "bb")]
|code|---code

|code|## Vérifier une preuve dans une telle structure de données
|code|
|code|---code
|code|let verif_deriv p grf mot = 
|code|    let i,j,m = p in
|code|    let achanger = soustrait i j mot in
|code|    List.mem (aechanger,m) grf.reglesf
|code|
|code|let verif_preuve p grf = 
|code|    let rec aux p mot = 
|code|        match p with
|code|            |[] -> true
|code|            |t::q -> 
|code|                let i,j,m = t in
|code|                (verif_deriv t grf) && (aux q (remplace i j mot))
|code|    in 
|code|    aux p [grf.axiome]

|code|---code

# Preuve automatique - grammaire formelle

Chercher automatiquement une preuve d'appartenance d'un mot à une grammaire non contextuelle se fait déjà très bien avec les automates à pile.
Nous allons ici nous intéresser plus spécifiquement aux grammaires formelles, et réutiliser notre méthode top-down.
La méthode s'applique alors directement de la même manière.
Nous avons donc un algorithme qui permet théoriquement de prouver que n'importe quel mot de la grammaire appartient bien à cette dernière.
Le problème étant la complexité de ce dernier, qui fonctionne comme une machine non déterministe où on ne coupe pas les instances arrivant à un état puit.
La suite va donc consister à trouver, de manière heuristique ou non, des méthodes affirmant qu'à partir d'un mot $m$, on aura des difficultés à dériver en notre mot $m'$ à prouver.
Alors, nous allons arrêter les recherches de dérivations de S en $m'$ qui passent par le mot $m$.

Pour ce faire, pour dériver un mot $m$ en mot $m'$, on calcule $S(x) := \{x \in \Sigma^\star \mid m \-> x\} 
=\{ubv \in \Sigma^\star \mid \exists (a,b) \in D / \exists (u,v)\in \Sigma^\star / x = uav\}$,
puis, pour chaque $ y \in S(x)$, on cherche une dérivation de $y$ en $m'$.

Pour calculer $S(x)$, il suffit de faire une recherche de facteur.

|code|D'où une implémentation en OCaml : 

|code|!nb !cremplace x i l b! donnera le mot !cx! où $x_{[i,i+l[}$ est remplacé par !cb!.

|code|!cppregles! est l'ensemble des règles de dérivation de la grammaire qui 
|code|sont prétraitées pour l'algorithme kmp.!cppregles! est donné par !cpreprocessgf grf!!
|code|---code
|code|let preprocessgf grf =
|code|  Array.map 
|code|  (fun (a,b) ->
|code|    (a,b,kmppreprocess a) 
|code|  )
|code|  grf.reglesf 

|code|let succ ppregles x = 
|code|  let res =
|code|  List.flatten
|code|  (
|code|    Array.to_list (
|code|      Array.map
|code|      (fun (a,b,pp) ->
|code|        List.map 
|code|        (fun i ->
|code|          remplace x i (Array.length a) b
|code|        )
|code|        (kmp x a pp)
|code|      )
|code|      ppregles
|code|    )
|code|  )
|code|  in
|code|  ajouteplein res []
|code|---code

|code|!csucc ppregles x! calcule $S(x)$.

## Un parcours en largeur particulier
Nous allons utiliser un parcours qui nous permettra de trouver dans un graphe un chemin plus court entre un sommet donné et un sommet 'valide'.
Ce parcours pourra aussi éviter les chemins passant par un sommet 'invalide'.

Alors on fournira à ce parcours une fonction !celimine! et une fonction !ctermine! toutes deux de type !csommet -> bool!.

Ce parcours est donc un parcours en largeur depuis un sommet $x_0$ qui garde en mémoire le chemin parcouru et qui s'arrête dès qu'un 
sommet $s$, tel que !ctermine s!, est parcouru. Il renvoit alors un chemin de $x_0$ à $s$. Lorsque le parcours passe par un sommet $s$ tel que !celimine s!, 
il ne parcourt pas ensuite ses voisins.

|code|En voici une implémentation OCaml :

|code|---code
|code|let rec parcoursmagique delta elimine termine dejavu avoir =
|code|  let navoir = ref [] in
|code|  let ndejavu = ref dejavu in
|code|  if avoir = [] then None else (
|code|  let res = 
|code|    List.find_opt
|code|    (function
|code|      |[] -> failwith "mauvais chemin"
|code|      |s::q ->
|code|        ndejavu := ajoute s (!ndejavu);
|code|        if (termine s) then true else
|code|        if (elimine s || List.mem s dejavu) then false else
|code|        (
|code|        navoir := 
|code|          ajouteplein
|code|          (
|code|            List.map
|code|            (fun v -> v::s::q)
|code|            (delta s)
|code|          )
|code|          (!navoir);
|code|        false)
|code|    )
|code|    avoir
|code|    in
|code|  match res with
|code|    |None -> parcoursmagique delta elimine termine (!ndejavu) (!navoir)
|code|    |Some x -> Some x
|code|  )
|code|---code

## Enfin, un prouveur automatique d'appartenance d'un mot à une grammaire formelle

Il ne nous reste plus qu'à appliquer notre parcours sur un graphe où les sommets sont les mots de $\Sigma^\star$, et les
arêtes sont $\{(a,b) \in  \Sigma^\star \mid a \rightarrow b\} = \{(a,b) \in \Sigma^\star \mid b \in S(a)\}$.

|code|En OCaml : 
|code|---code
|code|let chercherderivationnaif x m ppregles = 
|code|  parcoursmagique
|code|  (succ ppregles)
|code|  (fun x -> false)
|code|  (fun x -> x = m)
|code|  []
|code|  [[x]]
|code|---code

Par la suite, nous allons apporter des améliorations, en fournissant des fonctions !celimine!.

# Amélioration pour les grammaires croissantes

Une grammaire croissante est une grammaire telle que :
!equ!\forall (a,b) \in D, \norm{a} \leq \norm{b} !equ!
On a alors une première propriété très simple, $\forall m, m' \in \delta (S), m \overset{*}{\->} m' \implies \norm{m} \leq \norm{m'}$.

Alors, dans la recherche de dérivations de S vers m, on peut supprimer les "branches de recherche" qui partent d'un mot de longueur $> \norm{m}$.
Il ne reste qu'à faire le même parcours que précédement avec la fonction suivante comme fonction !celimine!.
|code|---code
|code|let eliminecroiss x = Array.length x > Array.length m
|code|---code

# Amélioration dans le cas général : déduction sur le nombre d'occurence de chaque lettre
Rappelons, le problème : étant donné un mot $m$ d'une grammaire, comment le dériver en un mot $m'$ ?
Pour tout $l \in \Sigma$, on va chercher un ensemble $q(l)$ qui majore $\norm{\delta(m)}_l$ ($=\{\norm{x}_l \mid x \in \delta(m)\}$).

Ainsi, $m \overset{*}{\->} m' \implies \norm{m'}_l \in q(l)$, la contraposée nous sera utile : 
!equu!
\norm{m'}_l \notin q(l) \implies  \neg (m \overset{*}{\->} m')
!equu!
Ce qui pourra nous permettre de réduire notre champ de recherche.
En effet, 

\fbox{si pour un mot $x \in \delta(m)$, $\forall l \in \Sigma, \norm{\delta(x)}_l \cap q(l) = \emptyset$,
 alors $m' \notin \delta(x)$}.

Pour calculer $\norm{\delta(x)}_l \cap q(l)$, nous allons utiliser un graphe semblable à un automate.

Les sommets sont des états de $Q \subset ({\mathcal{P}(\mathbb{N})})^{\Sigma}$ tels que :
---ml
    &\forall q,q' \in Q, \exists l \in \Sigma / q(l) \cap q'(l) = \emptyset\\
    \text{ et }&\forall m \in \delta(S), \exists q \in Q / \forall l \in \Sigma, \norm{m}_l \in q(l)
---ml

Ainsi à tout mot $x \in \delta(S)$, on peut associer un unique état $q$ tel que $\forall l \in \Sigma, \norm{x}_l \in q(l)$, notons cet état $cat(x)$

Les arêtes du graphe sont les dérivation possibles d'un famille majorante $q$ à une autre $q'$.
!equu!
    \forall (q,q') \in Q^2, (q,q') \in A \iff \exists x,x' \in \Sigma^\star / x \-> x' \text{ et } \forall l \in \Sigma, \norm{x}_l \in q(l) \text{ et } \norm{x'}_l \in q(l)
!equu!

Ainsi, si $m$ correspond à un état $q$, et $m'$ à un état $q'$, alors $m \overset{*}{\->} m' \implies$ $q'$ est accessible depuis $q$.

## Les états $q$ sous la forme $q \in Q = \{\{0\},\mathbb{N}^*\}^{\Sigma}$
|code|Exemple avec la grammaire suivante :
|code|$D := \{(S,!sabc!)_0,(!sabc!,!sab!)_1,(!sb!,!sk!)_2,(!sc!,!sak!)_3,(!skak!,!saa!)_4,(!sa!,!saaa!)_5\}$

|code|Le graphe est le suivant :

|code||tikz| !ftikzgrosgraphe!

|code|Et voici ce à quoi correspondent les différents états (sommets) du graphe : 

|code||tikz| !fbelletable!

|code|Le graphe réduit suivant sera utile : 

|code||tikz| !ftikzptitgraphe!

|code|Ainsi, nous pouvons tout de suite affirmer qu'il est impossible de dériver !saaabakab! en !sakkcckaaakck! (en effet, $\psi$ n'est pas accessible depuis $\delta$)

Intéressons nous au calcul des arrêtes $A$ du graphe.

Considérons d'abord les arêtes partant d'un état $q$ donné, puis celles correspondant à une dérivation $d$ donnée.

$A_q(\Sigma) := \{(a,b) \in A \mid a = q\}$

$A_{q,d}(\Sigma) := \{(a,b) \in A_q \mid \exists x,x' \in \Sigma^\star / x \overset{d}{\->} x' \text{ et } cat(x) = q \text{ et } cat(x') = q'\}$

Soit $l \in \Sigma$,

---t
$\Sigma ' := \Sigma \backslash \{l\}$

On a alors $A_q(\Sigma) = \bigcup_{d \in D} A_{q,d}(\Sigma)$ et $A = \bigcup_{q \in Q} A_q(\Sigma)$.

Et les $A_{q,d}(\Sigma)$ sont calculables de la manière suivante : 


Si $cat(b)(l) = \mathbb{N}^\star$, alors
---t
!equu!A_{q,d}(\Sigma) = \{(a,b) \in Q^2 \mid (a_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \mathbb{N}^\star\}!equu!
En effet, si $d$ produit la lettre $l$, elle est forcément dans le mot produit.
---tf


Si $cat(b)(l) = \{0\}$ et $q(l) = \{0\}$, alors 
---t
!equu!A_{q,d}(\Sigma) = \{(a,b) \in Q^2 \mid (a_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \{0\}\}!equu!
En effet, si $x$ ne contient pas la lettre $l$, et que $d$ ne produit pas la lettre $l$, le mot produit $x'$ n'aura pas de $l$.
---tf


Si $cat(b)(l) = \{0\}$ et $q(l) = \Sigma^\star$, alors
---t
---ml
A_{q,d}(\Sigma) = &\{(a,b) \in Q^2 \mid (a_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \{0\}\} \\
\cup &\{(a,b) \in Q^2 \mid (a_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \Sigma^\star\}
---ml
On ne peut rien dire, alors les deux prolongements possibles (sur la valeur de $b(l)$) seront explorés.
---tf
---tf

On peut alors calculer les arêtes du graphe.

Maintenant, une fois le graphe associé à notre grammaire calculé, on peut faire notre fonction !celimine!,
 !celimine x! renvoit vrai si et seulement si $x$ n'est pas accessible depuis S dans le graphe.
 (On peut précalculer le graphe réduit où les sommets sont les composantes fortement connexes et sa matrice
 d'accessibilité avec l'algorithme Floyd Washall par exemple, pour réduire les temps de calcul).