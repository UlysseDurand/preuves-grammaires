\maketitle
|code|\tableofcontents

# Définitions

## Les grammaires formelles

Une grammaire formelle est un quadruplet $G = (T,N_t,S,D)$ où :

---i
#### $T$ est l'alphabet des terminaux
#### $N_t$ est l'alphabet des non terminaux
#### $S \in N_t$ est l'axiome

Notons $\Sigma := N_t \cup T_0$
#### $D \subset (\Sigma ^ \star )^2$, est l'ensemble des règles de dérivation.
---i
Pour $(a,b) \in D$, soit $\overset{(a,b)}{\->}$ la relation binaire définie sur $\Sigma^\star$ par
!equu!
\forall m,m' \in \Sigma^\star, m \overset{(a,b)}{\->} m' \iff \exists u,v \in \Sigma^\star / m = uav \text{ et } m' = ubv
!equu!
On note $\-> := \bigcup_{d \in D} \overset{d}{\->}$ et on note $\overset{*}{\->}$ la cloture transitive et réflexive de $\->$.\\
Pour $x \in (\Sigma)^\star$, notons\\
$\delta(x) := \{y \in (\Sigma)^\star / x \overset{*}{\->} y\}$\\
$\eta(x) := \delta(x) \cap T^\star$\\
$\norm{x}_l := \norm{\{i \in \mathbb{N} \mid x_i = l \}}$ est le nombre d'occurences de la lettre $l$ dans x.

Alors le langage de la grammaire formelle  G est le suivant :
!equu!\mathcal{L} (G) := \eta(S)!equu!

Nous allons supposer que $N_t$ est dénombrable et $T$ est fini.

!nbcode typesetutiles debut types!

# Vérification de preuve - grammaire formelle

## Une nouvelle structure de données pour les preuves

Nous pouvons nous restreindre à la définition d'un mot qui dérive d'un autre.
On va alors fournir, comme preuve, une liste de mots $m_1, \dots, m_n$ tels que $\forall i\in [1,n-1], m_i \-> m_{i+1}$. 
Nous allons aussi renseigner de quelle manière le mot $m_{i+1}$ dérive du mot $m_i$ en fournissant l'indice de la règle de dérivation $(a,b)$ et celui du début de $a$ dans $m_i$ qui sera remplacé par $b$.
Nous aboutissons alors à :
---code
type 'e preuveformelle = (int*int*('e caractere list)) list
---code

!nbannexe exemple 1!
Nous prendrons comme exemple la grammaire formelle $G = (T,N_t,S,D)$ où :\\
$
T = \{!sa!,!sb!,!sc!\}\\
N_t = \{!sS!,!sB!\}\\
D = \{(!sS!,!saBSc!)_1,(!sS!,!sabc!)_2,(!sBa!,!saB!)_3,(!sBb!,!sbb!)_4\}
$,\\
alors !saabbcc! est dans $\mathcal{L}(G)$ car $!sS! \->_1 !saBSc! \->_2 !saBabcc! \->_3 !saaBbcc! \->_4 !saabbcc!$.\\
En Ocaml :
---code
let unepreuve = [(0,1,mot "aBSc");(2,3,mot "abc");(1,3,mot "aB");(2,4,mot "bb")]
---code
!nbcode verifderiv!

!nbcode verifpreuve!

# Preuve automatique - grammaire formelle

Nous allons générer successivement les $G_n := \{m \in \Sigma^\star \mid S (\bigcup_{0 \leq k \leq n} (\->)^k) m\}$ à l'aide de $G_{n+1} = \bigcup_{x \in G_n} S(x)$ où $S(x) := \{m \in \Sigma^\star \mid x \-> m \} = \bigcup_{d \in D} \{m \in \Sigma^\star \mid x \overset{d}{\->} m \}$
Pour ce faire, on trouve les successeurs d'un mot $x$ par $d = (a,b)$ en recherchant le motif $a$ dans $x$. (L'algorithe de Knuth-Morris-Pratt est adéquat). 
Nous avons donc un algorithme qui permet théoriquement de prouver que n'importe quel mot de la grammaire appartient bien à cette dernière.
Cet algorithme termine si et seulement si le mot à prouver est prouvable (si il est dans la grammaire).
Le problème étant la complexité de ce dernier, qui fonctionne comme une machine non déterministe où on ne coupe pas les instances arrivant à un état puit.
La suite va donc consister à trouver, de manière heuristique ou non, des méthodes affirmant qu'à partir d'un mot $m$, on aura des difficultés à dériver en notre mot $m'$ à prouver.
Alors, nous allons arrêter les recherches de dérivations de S en $m'$ qui passent par le mot $m$.

!nbcode preprocessgf et succ qui calcule $S(x)$!

## Un parcours en largeur particulier
Nous allons utiliser un parcours qui nous permettra de trouver dans un graphe un chemin plus court entre le sommet initial et un sommet 'valide'.
Ce parcours devra aussi éviter les chemins passant par un sommet 'interdit'.

Alors on fournira à ce parcours une fonction !cinterdit! et une fonction !cvalide! toutes deux de type !csommet -> bool!.

Ce parcours est donc un parcours en largeur depuis un sommet $x_0$ qui garde en mémoire le chemin parcouru et qui s'arrête dès qu'un 
sommet $s$, tel que !cvalide s!, est parcouru. Il renvoit alors un chemin de $x_0$ à $s$. Lorsque le parcours passe par un sommet $s$ tel que !cinterdit s!, 
il ne parcourt pas ensuite ses voisins.
!nbcode parcoursmagique!

## Enfin, un prouveur automatique d'appartenance d'un mot à une grammaire formelle

Il ne nous reste plus qu'à appliquer notre parcours sur un graphe où les sommets sont les mots de $\Sigma^\star$, et les
arêtes sont $\{(a,b) \in  \Sigma^\star \mid a \rightarrow b\} = \{(a,b) \in \Sigma^\star \mid b \in S(a)\}$.

!nbcode chercherderivationnarif!

Par la suite, nous allons apporter des améliorations, en fournissant des fonctions !cinterdit!.

# Amélioration pour les grammaires croissantes

Une grammaire croissante est une grammaire telle que :
!equ!\forall (a,b) \in D, \norm{a} \leq \norm{b} !equ!
On a alors une première propriété très simple, $\forall m, m' \in \delta (S), m \overset{*}{\->} m' \implies \norm{m} \leq \norm{m'}$.

Alors, dans la recherche de dérivations de S vers m, on peut supprimer les "branches de recherche" qui partent d'un mot de longueur $> \norm{m}$.
Il ne reste qu'à faire le même parcours que précédement avec la fonction suivante comme fonction !cinterdit!.
|code|---code
|code|let interditcroiss x = Array.length x > Array.length m
|code|---code

# Amélioration dans le cas général : déduction sur le nombre d'occurence de chaque lettre
Rappelons, le problème : étant donné un mot $m$ d'une grammaire, comment le dériver en un mot $m'$ ?
Pour tout $l \in \Sigma$, on va chercher un ensemble $q(l)$ qui majore $\norm{\delta(m)}_l$ ($=\{\norm{x}_l \mid x \in \delta(m)\}$).

Ainsi, $m \overset{*}{\->} m' \implies \norm{m'}_l \in q(l)$, la contraposée nous sera utile : 
!equu!
\norm{m'}_l \notin q(l) \implies  \neg (m \overset{*}{\->} m')
!equu!
Ce qui pourra nous permettre de réduire notre champ de recherche.
En effet, 

\fbox{si pour un mot $x \in \delta(m)$, $\forall l \in \Sigma, \norm{\delta(x)}_l \cap q(l) = \emptyset$,
 alors $m' \notin \delta(x)$}.

Pour calculer $\norm{\delta(x)}_l \cap q(l)$, nous allons utiliser un graphe semblable à un automate.

Les sommets sont des états de $Q \subset ({\mathcal{P}(\mathbb{N})})^{\Sigma}$ tels que :
---ml
    &\forall q,q' \in Q, \exists l \in \Sigma / q(l) \cap q'(l) = \emptyset\\
    \text{ et }&\forall m \in \delta(S), \exists q \in Q / \forall l \in \Sigma, \norm{m}_l \in q(l)
---ml

Ainsi à tout mot $x \in \delta(S)$, on peut associer un unique état $q$ tel que $\forall l \in \Sigma, \norm{x}_l \in q(l)$, notons cet état $cat(x)$

Les arêtes du graphe sont les dérivation possibles d'un famille majorante $q$ à une autre $q'$.
!equu!
    \forall (q,q') \in Q^2, (q,q') \in A \iff \exists x,x' \in \Sigma^\star / x \-> x' \text{ et } \forall l \in \Sigma, \norm{x}_l \in q(l) \text{ et } \norm{x'}_l \in q(l)
!equu!

Ainsi, si $m$ correspond à un état $q$, et $m'$ à un état $q'$, alors $m \overset{*}{\->} m' \implies$ $q'$ est accessible depuis $q$.

## Les états $q$ sous la forme $q \in Q = \{\{0\},\mathbb{N}^*\}^{\Sigma}$

!nbannexe exemple 2!


Exemple avec la grammaire suivante :
$D := \{(S,!sabc!)_0,(!sabc!,!sab!)_1,(!sb!,!sk!)_2,(!sc!,!sak!)_3,(!skak!,!saa!)_4,(!sa!,!saaa!)_5\}$

Le graphe est le suivant :

|tikz|!ftikzgrosgraphe!

Et voici ce à quoi correspondent les différents états (sommets) du graphe : 

|tikz|!fbelletable!

Le graphe réduit suivant sera utile : 

|tikz|!ftikzptitgraphe!

Ainsi, nous pouvons tout de suite affirmer qu'il est impossible de dériver !saaabakab! en !sakkcckaaakck! (en effet, $\psi$ n'est pas accessible depuis $\delta$)


Intéressons nous au calcul des arrêtes $A$ du graphe.

Considérons d'abord les arêtes partant d'un état $q$ donné, puis celles correspondant à une dérivation $d$ donnée.

$A_q(\Sigma) := \{(a,b) \in A \mid a = q\}$

$A_{q,d}(\Sigma) := \{(a,b) \in A_q \mid \exists x,x' \in \Sigma^\star / x \overset{d}{\->} x' \text{ et } cat(x) = q \text{ et } cat(x') = q'\}$

Soit $l \in \Sigma$,

---t
$\Sigma ' := \Sigma \backslash \{l\}$

On a alors $A_q(\Sigma) = \bigcup_{d \in D} A_{q,d}(\Sigma)$ et $A = \bigcup_{q \in Q} A_q(\Sigma)$.

Et les $A_{q,d}(\Sigma)$ sont majorables de la manière suivante : 


Si $cat(b)(l) = \mathbb{N}^\star$, alors
---t
!equu!A_{q,d}(\Sigma) \subset \{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \mathbb{N}^\star\}!equu!
En effet, si $d$ produit la lettre $l$, elle est forcément dans le mot produit.
---tf


Si $cat(b)(l) = \{0\}$ et $q(l) = \{0\}$, alors 
---t
!equu!A_{q,d}(\Sigma) \subset \{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \{0\}\}!equu!
En effet, si $x$ ne contient pas la lettre $l$, et que $d$ ne produit pas la lettre $l$, le mot produit $x'$ n'aura pas de $l$.
---tf


Si $cat(b)(l) = \{0\}$ et $q(l) = \Sigma^\star$, alors
---t
---ml
A_{q,d}(\Sigma) \subset &\{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \{0\}\} \\
\cup &\{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \Sigma^\star\}
---ml
On ne peut rien dire, alors les deux prolongements possibles (sur la valeur de $b(l)$) seront explorés.
---tf
---tf

On peut alors majorer l'ensemble des arêtes du graphe.

Maintenant, une fois le graphe majorant associé à notre grammaire calculé, on peut faire notre fonction !cinterdit!,
 !cinterdit x! renvoit vrai si et seulement si $x$ n'est pas accessible depuis S dans le graphe majorant.
 (On peut précalculer le graphe réduit où les sommets sont les composantes fortement connexes et sa matrice
 d'accessibilité avec l'algorithme Floyd Warshall par exemple, pour réduire les temps de calcul).
