\newcommand{\letitle}{Vérification et preuve automatique d'appartenance d'un mot à une grammaire formelle.}
\newcommand{\leauthor}{Ulysse Durand}
\newcommand{\lesubject}{Preuve grammaire}

\documentclass[12pt]{beamer}
\usepackage{tikzit}

\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{bbold}
\usepackage[xcolor,leftbars]{changebar}

\setbeamertemplate{footline}[frame number]
\setcounter{secnumdepth}{1}

\definecolor{DarkBlue}{RGB}{0,16,80}
\newcommand{\norm}[1]{\lvert #1 \rvert}
\usepackage{array,multirow,makecell}
\usepackage{subfig}
\setcellgapes{1pt}
\makegapedcells
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash }b{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash }b{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash }b{#1}}
\usepackage{hyperref}
\setlength{\parskip}{0.15cm}
\hypersetup{
    colorlinks=truem,
    linkcolor=black,
    filecolor=red,
    urlcolor=blue
}

\urlstyle{same}

\everymath{\displaystyle}
\title{\letitle}
\author{\leauthor}
\date{}
\begin{document}
\begin{frame}
\titlepage
\end{frame}
    \begin{frame}\frametitle{Les grammaires formelles}

$G = (T,N_t,S,D)$ où :
\begin{itemize}
\item $T$ est l'alphabet des terminaux
\item $N_t$ est l'alphabet des non terminaux
\item $S \in N_t$ est l'axiome

Notons $\Sigma := N_t \cup T$
\item $D \subset (\Sigma ^ \star )^2$ est l'ensemble des règles de dérivation.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Definitions}
\begin{itemize}
\item $\forall x,x' \in \Sigma^\star, x \overset{(a,b)}{\rightarrow} x' \iff \exists u,v \in \Sigma^\star / x = uav \text{ et } x' = ubv$

\item $\rightarrow := \bigcup_{d \in D} \overset{d}{\rightarrow}$ et on note $\overset{*}{\rightarrow}$ la cloture transitive et réflexive de $\rightarrow$

\item $\delta(x) := \{y \in \Sigma^\star / x \overset{*}{\rightarrow} y\}$

\item $\norm{x}_l := \norm{\{i \in \mathbb{N} \mid x_i = l \}}$ est le nombre d'occurences de la lettre $l$ dans x.

\item Alors le langage de la grammaire formelle  G est le suivant :
\begin{equation*}\mathcal{L} (G) := \delta(S) \cap T^\star\end{equation*}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Vérification de preuve}
$D = \{d_1,\dots,d_n\} = \{(a_1,b_1),\dots,(a_n,b_n)\}$

$S \overset{d_{\color{blue} i_1}}{\rightarrow} m_1 \overset{d_{\color{blue} i_2}}{\rightarrow} \dots \overset{d_{\color{blue} i_p}}{\rightarrow} m_p$

${m_k}_{\mid [1,{\color{blue} j_k} - 1]} {\color{red} a_{i_k} } {m_k}_{\mid [\norm{a_{{\color{blue} i_k}}} + {\color{blue} j_k},\norm{m_k}]} \overset{(a_{{\color{blue} i_k}},b_{{\color{blue} i_k}})}{\rightarrow} {m_k}_{\mid [1,{\color{blue} j_k} - 1]} {\color{red} b_{i_k} } {m_k}_{\mid [\norm{a_{{\color{blue} i_k}}} + {\color{blue} j_k},\norm{m_k}]}$

{\small \color{DarkBlue}\texttt{type 'e preuveformelle = \\
(('e caractere list)*int*int) list}}

{\small \color{DarkBlue}\texttt{[\dots ;(}}
$m_k$
{\small \color{DarkBlue}\texttt{,}}
$\color{blue} i_k$
{\small \color{DarkBlue}\texttt{,}}
$\color{blue} j_k$
{\small \color{DarkBlue}\texttt{);\dots ]}}
\end{frame}
\begin{frame}\frametitle{Vérification de preuve - Exemple}
$G = (T,N_t,S,D)$ où :
\begin{itemize}
\item $T = \{\underline{ a },\underline{ b },\underline{ c }\}$
\item $N_t = \{\underline{ S },\underline{ B }\}$
\item $D = \{(\underline{ S },\underline{ aBSc })_1,(\underline{ S },\underline{ abc })_2,(\underline{ Ba },\underline{ aB })_3,(\underline{ Bb },\underline{ bb })_4\}$
\end{itemize}

alors \underline{ aabbcc } est dans $\mathcal{L}(G)$ car $\underline{ S } \rightarrow_1 \underline{ aBSc } \rightarrow_2 \underline{ aBabcc } \rightarrow_3 \underline{ aaBbcc } \rightarrow_4 \underline{ aabbcc }$.

En Ocaml :

{\small \color{DarkBlue}\texttt{let unepreuve = [(mot "aBSc",0,0);(mot "aBabcc",1,2);
		 (mot "aaBbcc",2,1);(mot "aabbcc",3,2)]}}
\end{frame}

\begin{frame}\frametitle{Preuve automatique d'appartenance d'un mot}
Cherchons comment dériver \underline{ S } en un mot $m$ donné.
$G_n := \{x \in \Sigma^\star \mid S (\bigcup_{0 \leq k \leq n} \rightarrow^k) x\}$

$G_{n+1} = \bigcup_{x \in G_n} \mathcal{S}(x)$
où 
$\mathcal{S}(x) := \{y \in \Sigma^\star \mid x \rightarrow y \} = \bigcup_{d \in D} \{y \in \Sigma^\star \mid x \overset{d}{\rightarrow} y \}$
Algorithme de Knuth-Morris-Pratt pour le calcul de $\mathcal{S}(x)$

On fait en réalité un parcours en largeur du graphe $(\Sigma^\star,\rightarrow)$ depuis \underline{ S } pour trouver un chemin vers $m$.
\end{frame}

\begin{frame}\frametitle{Preuve automatique d'appartenance d'un mot - Le parcours en largeur}
On va éviter certains mots dans le parcours (ceux n'ayant aucune chance de dériver en m), et l'arrêter en arrivant sur $m$.

{\small \color{DarkBlue}\texttt{valide : ('e caractere list) -> bool\\
interdit : ('e caractere list) -> bool\\}}

On garde en mémoire le chemin parcouru.

\end{frame}

\begin{frame}\frametitle{Amélioration pour les grammaires croissantes}

\begin{equation*}\forall (a,b) \in D, \norm{a} \leq \norm{b} \end{equation*}

\begin{equation*}\forall x, x' \in \delta (S), x \overset{*}{\rightarrow} x' \implies \norm{x} \leq \norm{x'}\end{equation*}

{\small \color{DarkBlue}\texttt{let interditcroiss x = \\Array.length x > Array.length m}}
\end{frame}

\begin{frame}\frametitle{Amélioration dans le cas général : déduction sur le nombre d’occurence de chaque lettre}
Cherchons une fonction \texttt{ interdit } plus sophistiquée.

Pour tout $l \in \Sigma, x \in \Sigma^\star$, cherchons un ensemble $s_x(l)$ qui majore $\norm{\delta(x)}_l$ ($=\{\norm{y}_l \mid y \in \delta(x)\}$).

Ainsi, $x \overset{*}{\rightarrow} m \implies \forall l \in \Sigma, \norm{m}_l \in s_x(l)$

\begin{equation*}
\exists l \in \Sigma / \norm{m}_l \notin s_x(l) \implies \neg (x \overset{*}{\rightarrow} m)
\end{equation*}

\fbox{$\forall x \in \delta(S)$, $\exists l \in \Sigma, \norm{m}_l \notin s_x(l) \implies m \notin \delta(x)$}.

Alors \texttt{ interdit x } devra renvoyer vrai.
\end{frame}

\begin{frame}\frametitle{Calcul de $s_x$ - Description des mots}
On cherche à associer une description unique à un mot $x$ (par ses nombres d'occurences des lettres).

L'ensemble de ces descriptions sera
$Q \subset ({\mathcal{P}(\mathbb{N})})^{\Sigma}$ tel que :
\begin{align*}
    &\forall q,q' \in Q, \exists l \in \Sigma / q(l) \cap q'(l) = \emptyset\\
    \text{ et }&\forall m \in \delta(S), \exists q \in Q / \forall l \in \Sigma, \norm{m}_l \in q(l)
\end{align*}

Ainsi, grâce à ces deux axiomes, on a existence et unicité d'une telle description pour un mot $x$ donné.

$\forall x \in \delta(S), \exists ! q \in Q / \forall l \in \Sigma, \norm{x}_l \in q(l)$, notons cette description $cat(x)$.

On a ainsi partitionné $\Sigma^\star$ par $x \sim y \iff cat(x) = cat(y)$.
\end{frame}

\begin{frame}\frametitle{Calcul de $s_x$ - Le graphe $(Q,A_0)$}
Constuisons le graphe dont l'ensemble des sommets est $Q$ et les arêtes sont les dérivations possibles d'une description $q \in Q$ à une autre $q' \in Q$.
\begin{align*}
    &(q,q') \in A_0 \\
    &\iff \exists x,x' \in \Sigma^\star / x \rightarrow x' \text{ et } \forall l \in \Sigma, \norm{x}_l \in q(l) \text{ et } \norm{x'}_l \in q(l)\\
    &\iff \exists x,x' \in \Sigma^\star / x \rightarrow x' \text{ et } cat(x) = q \text{ et } cat(x') = q'
\end{align*}
On a en fait $A_0 = cat(\rightarrow)$.

Pour tout $(Q,A)$ majorant $(Q,A_0)$, $cat$ est un homomorphisme du graphe $(\Sigma^\star,\rightarrow)$ vers $(Q,A)$. ($x \rightarrow y \implies (cat(x),cat(y)) \in A$).

\end{frame}
\begin{frame}\frametitle{Calcul de $s_x$}
Ainsi, si $cat(x) = q$, et $cat(x')=q'$, alors $x \overset{*}{\rightarrow} x' \implies$ $q'$ est accessible depuis $q$ dans $(Q,A)$.

Voilà une condition nécessaire pour que $x \overset{*}{\rightarrow} m$.

On prend $s_x / \forall l \in \Sigma$, $s_x(l) = \bigcup_{y / x\overset{*}{\rightarrow} y} cat(y)(l) = \bigcup_{q\text{ accessible depuis } cat(x) \text{ dans A}}q(l)$.

\fbox{\parbox{\linewidth}{
    Si $cat(m)$ n'est pas accessible depuis $cat(x)$ dans un graphe $(Q,A)$ majorant $(Q,A_0)$, 
    alors on peut interdire le parcours passant par $x$, \texttt{ interdit x } renverra vrai.
}}
\end{frame}

\begin{frame}\frametitle{Les états $q$ sous la forme $q \in Q = \{\{0\},\mathbb{N}^*\}^{\Sigma}$}

$D = \{(S,\underline{ abc })_0,(\underline{ abc },\underline{ ab })_1,(\underline{ b },\underline{ k })_2,(\underline{ c },\underline{ ak })_3,(\underline{ kak },\underline{ aa })_4,(\underline{ a },\underline{ aaa })_5\}$

\begin{figure}
    \centering
    \subfloat[\centering Le graphe A]{\scalebox{0.7}[0.7]{\tikzfig{grosgraphe}}}
    \qquad
    \subfloat[\centering Ses sommets]{\hspace{-2cm}\input{figures/belltablevert.tex}}
\end{figure}

\end{frame}

\begin{frame}\frametitle{Les états $q$ sous la forme $q \in Q = \{\{0\},\mathbb{N}^*\}^{\Sigma}$}

\tikzfig{ptitgraphe}

Ainsi, nous pouvons tout de suite affirmer qu'il est impossible de dériver \underline{ aaabakab } en \underline{ akkcckaaakck } (en effet, $\psi$ n'est pas accessible depuis $\delta$)

\end{frame}

\begin{frame}\frametitle{Calcul des arêtes $A$ du graphe (1)}
Pour une dérivation $(a,b)$ fixée, notons\\
$A_{(a,b)} := \{(q,q') \in A \mid \exists x,x' \in \Sigma^\star / x \overset{(a,b)}{\rightarrow} x' \text{ et } cat(x) = q \text{ et } cat(x') = q'\}$

Pour calculer les $(q,q') \in A_{(a,b)}$(majorant ${A_0}_{(a,b)}$), trouvons des conditions nécessaires telles que $\exists x,y / cat(x) = q \text{ et } cat(y) = q \text { et } x \overset{(a,b)}{\rightarrow} y$.
\end{frame}

\begin{frame}\frametitle{Calcul des arêtes $A$ du graphe (2)}
$(\exists x,y / cat(x) = q \text{ et } cat(y) = q \text { et } x \overset{(a,b)}{\rightarrow} y) \implies$
\begin{itemize}
\item $x$ doit contenir les lettres de $a$, donc $cat(a) \preceq cat(x)$ où\\ $\forall \alpha, \beta \in Q, (\alpha \preceq \beta) \iff \forall l \in \Sigma, \max \alpha(l) \leq \min \beta(l)$.

\item $y$ doit contenir au moins les lettres de $x$ moins celles de $a$, donc $cat(x)-cat(a) \preceq cat(y)$ où\\ $\forall \alpha,\beta \in Q, \alpha-\beta : l \mapsto 
\begin{cases}
\{0\} & \text { si } q'(l) = \mathbb{N} \text{ ou }q(l) = \{0\}\\
\mathbb{N} & \text{sinon}
\end{cases}
$

\item Pour $l \in \Sigma$, si $l$ est dans $b$, $l$ sera dans $y$, donc $cat(b)(l) = \mathbb{N}^* \implies cat(y)(l) \mathbb{N}^*$. 

\item Pour $l \in \Sigma$, si $x$ ne contient pas $l$ et $b$ non plus, y ne contiendra pas $l$, donc $cat(x)(l) = \{0\}$ et $cat(b)(l) = \{0\} \implies cat(y)(l) = \{0\}$.

\end{itemize}

\end{frame}

\begin{frame}\frametitle{Calcul des arêtes $A$ du graphe (3)}

On en déduit
\begin{align*}
&A_{(a,b)} = \\
&\{(q,q') \in Q^2 \mid \\
&
\begin{cases}
    &cat(a) \preceq q \text{ et }\\
    &q-cat(a) \preceq q' \text{ et }\\ 
    &\forall l \in \Sigma,\\
    &\text{\hspace{1cm}}(cat(b)(l)=\mathbb{N}^* \implies q'(l)=\mathbb{N}^*) \text{ et }\\
    &\text{\hspace{1cm}}(q(l)=\{0\} \text{ et } cat(b)(l) = \{0\} \implies q'(l)=\{0\})
\end{cases}
\\
&\}
\end{align*}
et 
$A = \bigcup_{q \in Q}  \bigcup_{d \in D} A_{q,d}$.

\end{frame}

\begin{frame}\frametitle{Conclusion}
En précalculant la matrice d'accessibilité de A (avec Floyd-Warshall), on a une fonction \texttt{ elimine x } s'executant en $\mathcal{O} (|x|)$.

On arrive alors dans certains cas à réduire le temps de recherche d'une preuve d'appartenance du mot $m$ au langage de notre grammaire.

Mais, seulement 3 appels à \texttt{ inderdit } réussis pour dériver \underline{ S } en \underline{ aaakaaak } de profondeur 5...

Prétraitement couteux

Extension probablement possible (mais aussi peu utile ?) pour $Q \subset \{2 \mathbb{N} , 2 \mathbb{N} + 1 \}^\Sigma$
\end{frame}


\end{document}
    