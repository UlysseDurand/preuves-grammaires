\newcommand{\letitle}{Sur la vérification de preuve et la preuve automatique d'appartenance d'un mot à une grammaire.}
\newcommand{\leauthor}{Ulysse Durand}
\newcommand{\lesubject}{Preuve grammaire}

\documentclass[12pt]{beamer}
\usepackage{tikzit}

\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{bbold}
\usepackage[xcolor,leftbars]{changebar}

\setbeamertemplate{footline}[frame number]
\setcounter{secnumdepth}{1}

\definecolor{DarkBlue}{RGB}{0,16,80}
\newcommand{\norm}[1]{\lvert #1 \rvert}
\usepackage{array,multirow,makecell}
\usepackage{subfig}
\setcellgapes{1pt}
\makegapedcells
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash }b{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash }b{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash }b{#1}}
\usepackage{hyperref}
\setlength{\parskip}{0.15cm}
\hypersetup{
    colorlinks=truem,
    linkcolor=black,
    filecolor=red,
    urlcolor=blue
}

\urlstyle{same}

\everymath{\displaystyle}
\title{\letitle}
\author{\leauthor}
\date{}
\begin{document}
\begin{frame}
\titlepage
\end{frame}
    \begin{frame}\frametitle{Les grammaires formelles}

$G = (T,N_t,S,D)$ où :
\begin{itemize}
\item $T$ est l'alphabet des terminaux
\item $N_t$ est l'alphabet des non terminaux
\item $S \in N_t$ est l'axiome

Notons $\Sigma := N_t \cup T$
\item $D \subset (\Sigma ^ \star )^2$, est l'ensemble des règles de dérivation.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Definitions}
\begin{itemize}
\item $\forall x,x' \in \Sigma^\star, x \overset{(a,b)}{\rightarrow} x' \iff \exists u,v \in \Sigma^\star / x = uav \text{ et } x' = ubv$

\item $\rightarrow := \bigcup_{d \in D} \overset{d}{\rightarrow}$ et on note $\overset{*}{\rightarrow}$ la cloture transitive et réflexive de $\rightarrow$

\item $\delta(x) := \{y \in \Sigma^\star / x \overset{*}{\rightarrow} y\}$

\item $\norm{x}_l := \norm{\{i \in \mathbb{N} \mid x_i = l \}}$ est le nombre d'occurences de la lettre $l$ dans x.

\item Alors le langage de la grammaire formelle  G est le suivant :
\begin{equation*}\mathcal{L} (G) := \delta(S) \cap T^\star\end{equation*}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Vérification de preuve}
$D = \{d_1,\dots,d_n\} = \{(a_1,b_1),\dots,(a_n,b_n)\}$

$S \overset{d_{\color{blue} i_1}}{\rightarrow} m_1 \overset{d_{\color{blue} i_2}}{\rightarrow} \dots \overset{d_{\color{blue} i_p}}{\rightarrow} m_p$

${m_k}_{\mid [1,{\color{blue} j_k} - 1]} {\color{red} a } {m_k}_{\mid [\norm{a_{{\color{blue} i_k}}} + {\color{blue} j_k},\norm{m_k}]} \overset{(a_{{\color{blue} i_k}},b_{{\color{blue} i_k}})}{\rightarrow} {m_k}_{\mid [1,{\color{blue} j_k} - 1]} {\color{red} b } {m_k}_{\mid [\norm{a_{{\color{blue} i_k}}} + {\color{blue} j_k},\norm{m_k}]}$

{\small \color{DarkBlue}\texttt{type 'e preuveformelle = \\
(int*int*('e caractere list)) list}}

{\small \color{DarkBlue}\texttt{[\dots ,(}}
$\color{blue} i_k$
{\small \color{DarkBlue}\texttt{,}}
$\color{blue} j_k$
{\small \color{DarkBlue}\texttt{,}}
$m_k$
{\small \color{DarkBlue}\texttt{),\dots ]}}
\end{frame}
\begin{frame}\frametitle{Vérification de preuve - Exemple}
$G = (T,N_t,S,D)$ où :
\begin{itemize}
\item $T = \{\underline{ a },\underline{ b },\underline{ c }\}$
\item $N_t = \{\underline{ S },\underline{ B }\}$
\item $D = \{(\underline{ S },\underline{ aBSc })_1,(\underline{ S },\underline{ abc })_2,(\underline{ Ba },\underline{ aB })_3,(\underline{ Bb },\underline{ bb })_4\}$
\end{itemize}

alors \underline{ aabbcc } est dans $\mathcal{L}(G)$ car $\underline{ S } \rightarrow_1 \underline{ aBSc } \rightarrow_2 \underline{ aBabcc } \rightarrow_3 \underline{ aaBbcc } \rightarrow_4 \underline{ aabbcc }$.

En Ocaml :

{\small \color{DarkBlue}\texttt{let unepreuve = [(0,1,mot "aBSc");(2,3,mot "abc");(1,3,mot "aB");(2,4,mot "bb")]}}
\end{frame}

\begin{frame}\frametitle{Preuve automatique d'appartenance d'un mot}
Cherchons comment dériver \underline{ S } en un mot $m$ donné.
$G_n := \{x \in \Sigma^\star \mid S (\bigcup_{0 \leq k \leq n} \rightarrow^k) x\}$

$G_{n+1} = \bigcup_{x \in G_n} \mathcal{S}(x)$
où 
$\mathcal{S}(x) := \{y \in \Sigma^\star \mid x \rightarrow y \} = \bigcup_{d \in D} \{y \in \Sigma^\star \mid x \overset{d}{\rightarrow} y \}$
l'algorithme de Knuth-Morris-Pratt pour le calcul de $\mathcal{S}(x)$

On fait en réalité un parcours en largeur du graphe $(\Sigma^\star,\rightarrow)$ depuis \underline{ S } pour trouver un chemin vers $m$.
\end{frame}

\begin{frame}\frametitle{Preuve automatique d'appartenance d'un mot - Le parcours en largeur}
On va éviter certains mots dans le parcours (ceux n'ayant aucune chance de dériver en m), et l'arrêter en arrivant sur $m$.

{\small \color{DarkBlue}\texttt{valide : ('e caractere list) -> bool\\
interdit : ('e caractere list) -> bool\\}}

On garde en mémoire le chemin parcouru.

\end{frame}

\begin{frame}\frametitle{Amélioration pour les grammaires croissantes}

\begin{equation*}\forall (a,b) \in D, \norm{a} \leq \norm{b} \end{equation*}

\begin{equation*}\forall x, x' \in \delta (S), x \overset{*}{\rightarrow} x' \implies \norm{x} \leq \norm{x'}\end{equation*}

{\small \color{DarkBlue}\texttt{let interditcroiss x = \\Array.length x > Array.length m}}
\end{frame}

\begin{frame}\frametitle{Amélioration dans le cas général : déduction sur le nombre d’occurence de chaque lettre}
Cherchons une fonction \texttt{ interdit } plus sophistiquée.

Pour tout $l \in \Sigma, x \in \Sigma^\star$, cherchons un ensemble $s_x(l)$ qui majore $\norm{\delta(x)}_l$ ($=\{\norm{y}_l \mid y \in \delta(x)\}$).

Ainsi, $x \overset{*}{\rightarrow} m \implies \forall l \in \Sigma, \norm{m}_l \in s_x(l)$

\begin{equation*}
\exists l \in \Sigma / \norm{m}_l \notin s_x(l) \implies \neg (x \overset{*}{\rightarrow} m)
\end{equation*}

\fbox{$\forall x \in \delta(S)$, $\exists l \in \Sigma, \norm{m}_l \notin s_x(l) \implies m \notin \delta(x)$}.

Alors \texttt{ interdit x } devra renvoyer vrai.
\end{frame}

\begin{frame}\frametitle{Calcul de $s_x$ - Le graphe $A_0$ (1)}
Considérons le graphe $A_0$ où les sommets sont dans 
$Q \subset ({\mathcal{P}(\mathbb{N})})^{\Sigma}$ tels que :
\begin{align*}
    &\forall q,q' \in Q, \exists l \in \Sigma / q(l) \cap q'(l) = \emptyset\\
    \text{ et }&\forall m \in \delta(S), \exists q \in Q / \forall l \in \Sigma, \norm{m}_l \in q(l)
\end{align*}

Ainsi, $\forall x \in \delta(S), \exists ! q \in Q / \forall l \in \Sigma, \norm{x}_l \in q(l)$, notons ce sommet $cat(x)$
\end{frame}

\begin{frame}\frametitle{Calcul de $s_x$ - Le graphe $A_0$ (2)}

Les arêtes du graphe sont les dérivation possibles d'un famille majorante $q \in Q$ à une autre $q' \in Q$.
\begin{align*}
    &(q,q') \in A_0 \\
    &\iff \exists x,x' \in \Sigma^\star / x \rightarrow x' \text{ et } \forall l \in \Sigma, \norm{x}_l \in q(l) \text{ et } \norm{x'}_l \in q(l)\\
    &\iff \exists x,x' \in \Sigma^\star / x \rightarrow x' \text{ et } cat(x) = q \text{ et } cat(x') = q'
\end{align*}
Pour A un graphe majorant $A_0$ : 

On a $\forall l \in \Sigma$, $s_x(l) = \bigcup_{q\text{ accessible depuis } cat(x) \text{ dans A}}q(l)$.
\end{frame}
\begin{frame}\frametitle{Calcul de $s_x$ - Le graphe $A_0$ (3)}
Ainsi, si $cat(x) = q$, et $cat(x')=q'$, alors $x \overset{*}{\rightarrow} x' \implies$ $q'$ est accessible depuis $q$ dans $A$. 

\fbox{\parbox{\linewidth}{
    Si $m$ n'est pas accessible depuis $x$ dans un graphe $A$ majorant $A_0$, 
    alors on peut interdire le parcours passant par $x$, \texttt{ interdit x } renverra vrai.
}}
\end{frame}

\begin{frame}\frametitle{Les états $q$ sous la forme $q \in Q = \{\{0\},\mathbb{N}^*\}^{\Sigma}$}

$D = \{(S,\underline{ abc })_0,(\underline{ abc },\underline{ ab })_1,(\underline{ b },\underline{ k })_2,(\underline{ c },\underline{ ak })_3,(\underline{ kak },\underline{ aa })_4,(\underline{ a },\underline{ aaa })_5\}$

\begin{figure}
    \centering
    \subfloat[\centering Le graphe A]{\scalebox{0.7}[0.7]{\tikzfig{grosgraphe}}}
    \qquad
    \subfloat[\centering Ses sommets]{\hspace{-2cm}\input{figures/belltablevert.tex}}
\end{figure}

\end{frame}

\begin{frame}\frametitle{Les états $q$ sous la forme $q \in Q = \{\{0\},\mathbb{N}^*\}^{\Sigma}$}

\tikzfig{ptitgraphe}

Ainsi, nous pouvons tout de suite affirmer qu'il est impossible de dériver \underline{ aaabakab } en \underline{ akkcckaaakck } (en effet, $\psi$ n'est pas accessible depuis $\delta$)

\end{frame}

\begin{frame}\frametitle{Calcul des arrêtes $A$ du graphe}
Pour un sommet de départ fixé et une dérivation fixée.
$A_{q,d}(\Sigma) := \{(q,b) \in A \mid \exists x,x' \in \Sigma^\star / x \overset{d}{\rightarrow} x' \text{ et } cat(x) = q \text{ et } cat(x') = q'\}$

Soit $l \in \Sigma$, $\Sigma ' := \Sigma \backslash \{l\}$, $A = \bigcup_{q \in Q}  \bigcup_{d \in D} A_{q,d}(\Sigma)$.

\begin{itemize}
\item $cat(b)(l) = \mathbb{N}^\star$
\begin{equation*}A_{q,d}(\Sigma) \subset \{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \mathbb{N}^\star\}\end{equation*}

\item $cat(b)(l) = \{0\}$ et $q(l) = \{0\}$
\begin{equation*}A_{q,d}(\Sigma) \subset \{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \{0\}\}\end{equation*}

\item $cat(b)(l) = \{0\}$ et $q(l) = \Sigma^\star$
\begin{align*}
A_{q,d}(\Sigma) \subset &\{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \{0\}\} \\
\cup &\{(q,b) \in Q^2 \mid (q_{\Sigma '},b_{\Sigma '}) \in A_{q,d}(\Sigma ') \text{ et } b(l) = \Sigma^\star\}
\end{align*}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Conclusion}
En précalculant la matrice d'accessibilité de A (avec Floyd-Warshall), on a une fonction \texttt{ elimine x } s'executant en temps constant.

On arrive alors à réduire le temps de recherche d'une preuve d'appartenance du mot $m$ au langage de notre grammaire.

Extension probablement possible pour $Q \subset \{2 \mathbb{N} , 2 \mathbb{N} + 1 \}^\Sigma$
\end{frame}

\end{document}
    