
import json, os, glob
infoexists = os.path.isfile("../infos.json")
data = {}
if infoexists:
    data = json.loads(open("../infos.json").read())
        
def loadpackages():
    for e in glob.glob("./*.sty"):
        print("\\usepackage{"+e[2:-4]+"}")

if infoexists:
    for key,value in data.items():
        print("\\newcommand{\\le"+key+"}{"+value+"}")
else:
    print("\\newcommand{\\letitle}{}")
    print("\\newcommand{\\leauthor}{}")
    
print("\n\\documentclass[a4paper,",end='')

if "taillepolice" in data:
    print(data["taillepolice"])
else:
    print("12pt",end='')

print("]{article}\n",end='')

loadpackages()

print("\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb}\n\\usepackage{amsmath}\n\\usepackage{xcolor}\n\\usepackage{enumitem}\n\\usepackage[margin=3cm]{geometry}\n\\usepackage{bbold}\n\\usepackage[xcolor,leftbars]{changebar}\n\n\\setcounter{secnumdepth}{1}\n\\newenvironment{myindentpar}\n {\\begin{list}{}\n         {\\setlength{\\leftmargin}{1em}}\n         \\item[]\n }\n { \\end{list}}\n\n\\newcommand{\\norm}[1]{\\lvert #1 \\rvert}\n\\newsavebox{\\mybox}\n\\newlength{\\mydepth}\n\\newlength{\\myheight}\n\\newenvironment{answer}\n{\\par\\begin{lrbox}{\\mybox}\\quad\\begin{minipage}{\\linewidth}\\color{black}\\setlength{\\parskip}{10pt plus 1pt minus 1pt}\\vspace*{-.7\\baselineskip}}\n{\\end{minipage}\\end{lrbox}\n\\settodepth{\\mydepth}{\\usebox{\\mybox}}\n\\settoheight{\\myheight}{\\usebox{\\mybox}}\n\\addtolength{\\myheight}{\\mydepth}\n\\noindent\\makebox[0pt]{\n  \\color{gray}\\hspace{-0pt}\\rule[-\\mydepth]{1pt}{\\myheight}}\n  \\usebox{\\mybox}\n  }\n\n\\usepackage{hyperref}\n\\setlength{\\parskip}{0.15cm}\n\\hypersetup{\n    colorlinks=truem,\n    linkcolor=black,\n    filecolor=red,\n    urlcolor=blue\n}\n\n\\urlstyle{same}\n\n\\everymath{\\displaystyle}\n\\title{\\letitle}\n\\author{\\leauthor}\n\\date{}\n\\begin{document}\n    ",end='')

print("\n\\maketitle\n\\tableofcontents\n\n\\section{Définitions}\n\n\\subsection{Les grammaires formelles}\n\nUne grammaire formelle est un quadruplet $G = (T,N_t,S,D)$ où :\n\n\\begin{itemize}\n\\item $T$ est l\'alphabet des terminaux\n\\item $N_t$ est l\'alphabet des non terminaux\n\\item $S \\in N_t$ est l\'axiome\n\\item $D$, un ensemble d\'éléments de $(N_t \\cup T)^\\star \\times (N_t \\cup T)^\\star$, est l\'ensemble des règles de dérivation.\n\\end{itemize}\n\nSoit $\\rightarrow$ la relation binaire définie sur $(N_t \\cup T)^\\star$ par\n\\begin{equation}\n\\forall m,m\' \\in (N_t \\cup T)^\\star, m \\rightarrow m\' \\iff \\exists (a,b) \\in D, u,v \\in (N_t \\cup T)^\\star / m = uav \\text{ et } m\' = ubv\n\\end{equation}\nOn note $\\overset{*}{\\rightarrow}$ la cloture transitive et réflexive de $\\rightarrow$.\\\\\nPour $x \\in (N_t \\cup T)^\\star$, notons\n\n$\\delta(x) := \\{y \\in (N_t \\cup T)^\\star / x \\overset{*}{\\rightarrow} y\\}$\net \n\n$\\eta(x) := \\delta(x) \\cap T^\\star$.\n\nAlors le langage de la grammaire formelle  G est le suivant :\n\\begin{equation*}\\mathcal{L} (G) := \\eta(S)\\end{equation*}\n\nNous allons supposer que $N_t$ est dénombrable et $T$ est fini.\n\nEn OCaml :\n\\begin{verbatim}\ntype \'e caractere = T of \'e | Nt of int\n\ntype \'a reglec = (\'a list) * (\'a list)\n\ntype \'e fg = {\n    terminaux : \'e array ;\n    nonterminaux : \'e array ;\n    axiome : \'e caractere ;\n    reglesf : (\'e caractere) reglef array \n}\n\\end{verbatim}\n\\subsection{Les grammaires non contextuelle}\n\n\\textbf{  Définition : } Une grammaire non contextuelle est une grammaire $G = (T,N_t,S,D)$ telle que :\n\\begin{equation*} \\forall (a,b) \\in D, a \\in N_t  \\end{equation*}\n\n\n\\begin{verbatim}\ntype \'a reglenc = (\'a list) * (\'a list)\n\ntype \'e cfg = {\n    terminaux : \'e array ;\n    nonterminaux : \'e array ;\n    axiome : \'e caractere ;\n    reglesnc : (\'e caractere) reglenc array \n}\n\\end{verbatim}\n\n\\textbf{ Exemple : } la grammaire non contextuelle des expressions arithmétiques suffixes.\n\\begin{align*}\nD = &\\{(S,SS+)_1,(S,SS*)_2,(S,\"N\")_3\\}\\\\\n\\cup&\\{(N,C)_4 | (N,NC)_5\\}\\\\\n\\cup&\\{(C,0)_6 | (C,1)_7\\}\n\\end{align*}\n(les indices dessus correspondent à une énumération des règles de dérivation, par exemple, $D_5 = (N,NC)$)\n\n\\subsection{Fôret de dérivation}\n\nIci, $G = (T,N_t,S,D)$ est une grammaire non contextuelle.\n\nUne forêt est une liste d\'arbres\n\\begin{verbatim}\ntype \'a arbre = \'a * \'a foret and\ntype \'a foret = \'a arbre list\n\\end{verbatim}\n\n\nUne preuve qu\'un mot appartient à $\\eta(m)$ peut être donnée par une forêt de dérivation :\n\n\\begin{answer} \nSi $m$ est le mot vide, il s\'agit de la forêt vide.\n\nSinon, soit $n = \\norm{m}$,\\\\\n\\begin{answer} \n    Si $n=1$, il s\'agit d\'un seul arbre où la racine est $m$ et chaque sous arbres est la forêt de dérivation d\'un $b$ tel que $(m,b) \\in D$.\n\n    Si $n>1$, il s\'agit de la liste des arbres $[f_1, \\dots, f_n]$ où $\\forall i \\in [1,n], f_i$ est un arbre de dérivation de la lettre $m_i$.\n\\end{answer}\n\\end{answer}\n\n\\begin{verbatim}\nlet test_foret_deriv f m gram = match m with\n    |[] -> f = []\n    |[x] -> \n        List.exists \n        (fun (a,b) -> x = a && test_foret_deriv f b gram) \n        gram.reglesnc\n    |t1::q1 -> \n        match f with\n            |[] -> false\n            |t2::q2 -> (test_foret_deriv [t2] [t1]) && (test_foret_deriv q2 q1)\n\\end{verbatim}\n\n\nL\'ensemble des forêts de dérivation de $m$ est noté $\\mathcal{F}(m)$.\n\n\\begin{verbatim}\ntype \'e caractere = T of \'e | Nt of int\n\\end{verbatim}\n\nLe parcours infixe des feuilles d\'une forêt de dérivation de $x$ donne un mot de $\\eta(x)$.\nUn exemple sera donnée dans le cas d\'une grammaire non contextuelle.\n\nPour $a \\in \\mathcal{F}(x)$, on note $\\mathcal{I}(a)$ le parcours infixe des feuilles de $a$. \n\n\\subsection{Exemple de preuve}\n\nUne preuve que \"10\"\"11\"+\"0\"* $\\in \\mathcal{L}(G)$ :\\\\\nLemme 1 : \"10\" $\\in \\eta(S)$\n\n    En effet, $S\\rightarrow_3 \"N\" \\rightarrow_5 \"NC\" \\rightarrow_6 \"N0\" \\rightarrow_4 \"C0\" \\rightarrow_7 \"10\"$\n\n\nL\'abre de dérivation fait aussi office de preuve, bien plus concise :\n   \\input{figures/tree1.tikz}\n\nLemme 2 : \"11\" $\\in \\eta(S)$\nPreuve avec l\'arbre suivant\n \\input{figures/tree2.tikz}\n\nOn peut alors, en combinant les deux arbres précédants, prouver que \"10\"\"11\"+ $\\in \\eta(S)$ :\n \\input{figures/tree3.tikz}\n\nAvec l\'arbre suivant, on prouve enfin que \"10\"\"11\"+\"0\"* $\\in \\delta(S) \\cap T^\\star = \\mathcal{L}(G)$ :\n \\input{figures/tree4.tikz}\n\nOn remarque bien qu\'un parcours infixe des feuilles de l\'arbre donne \"10\"\"11\"+\"0\"*\n\n\\section{Vérification de preuve pour une grammaire non contextuelle}\n\nLa forêt de dérivation nous donne une bonne manière de vérifier une preuve, car une preuve est caractérisé par une forêt de dérivation.\\\\\n\n(en pratique, \'e sera string).\n\nPar induction on peut montrer $m \\in \\eta(x) \\iff $ il existe $p$ une forêt de dérivation dont le parcours infixe des feuilles est $m$ et les racines sont les lettres de $x$.\n\n{\\color{gray} NB : $A_{[p,q]}$ correspond à la forêt $A$ restreinte à ses arbres d\'indice $i / p\\leq i \\leq q$ et $A@B$ correspond à la concaténation des forêts $A$ et $B$. }\\\\\n\n\\begin{answer} \n$\nm \\in \\eta(x)\\\\\n\\iff \\exists n \\in \\mathbb{N} / \\exists m_1,m_2,\\dots,m_n \\in (N_t \\cup T)^\\star / x \\rightarrow m_1 \\rightarrow m_2 \\rightarrow \\dots \\rightarrow m_n\\text{ et }m_n \\in T^\\star$    $ (2_n)\\\\\n\\mathcal{P}(n) := ((2_n) \\implies \\exists A \\in \\mathcal{F}(x) / \\mathcal{I}(x) = m)$\\\\\n\\begin{answer} \n$\\mathcal{P}(0) : x \\in \\eta(x) \\implies x \\in T^\\star$ donc $[B (x_1);\\dots;B (x_{\\norm{x}})]$ convient.\\\\\n$\\forall n \\in \\mathbb{N}^*,\\mathcal{P}(n-1) \\implies (m \\in \\eta(m_1) \\implies \\exists A \\in \\mathcal{F}(m_1)/ \\mathcal{I}(A) = m)$\n\n et comme $x\\rightarrow m_1,\\exists (a,b) \\in D, u,v\\in (N_t\\cup T)^\\star /x = uav$ et $m_1 = ubv$\n\n Soit $p := \\norm{u}, q := \\norm{v}, r := \\norm{b}$\n \n alors $A|_{[1,p]} \\in \\mathcal{F}(u), A|_{[p+1,p+r]} \\in \\mathcal{F}(b), A|_{[p+r+1,p+r+q]} \\in \\mathcal{F}(v)$\n\n Donc $A|_{[1,p]}@A\'@A|_{[p+r+1,p+r+q]}\\in \\mathcal{F}(x)$ où $A\' = N (b,A|_{[p+1,p+r]})$\n\n Soit $\\mathcal{P}(n)$.\n\\end{answer}\n\\end{answer}\nLa réciproque se montre avec un algorithme qui à un arbre de dérivation associe une séquence $m_1,m_2,\\dots,m_n \\in (N_t \\cup T)^\\star$ telle que $x \\rightarrow m_1 \\rightarrow m_2 \\rightarrow \\dots \\rightarrow m_n$\n\nEn entrée, nous avons $f_0$, une forêt de dérivation.\n\\begin{answer} \n$f$ est une copie de $f_0$. \n\nTant que $f$ n\'est pas constituée que de feuilles :\n\n\\begin{answer} \n    On prend $a$ un arbre qui n\'est pas une feuille dans $f$\n\n    Remplacer $a$, dans $f$, par ses fils.\n\n    Lire les racines de la forêt de gauche à droite.\n\\end{answer}\n\\end{answer}\nEn remplaçant $a$ dans $f$ par ses fils, on dérive notre mot une fois.\\\\\\\\\n\n\\fbox{Alors $a \\in \\mathcal{F}(S)$ est une preuve que $\\mathcal{I}(a) \\in \\mathcal{L}(G)$.}\n\nAlors, vérifier une preuve donnée par une forêt consiste juste à vérifier que la forêt est bien une forêt de dérivation.\n\n\\section{Preuve automatique en grammaire non contextuelle}\n\nToujours dans une grammaire non contextuelle\n\nAvec une grammaire dont l\'axiome est S,\npour générer automatiquement une preuve, l\'idée est qu\'à chaque étape,\non dispose d\'une liste de mots prouvés,\net à chaque étape, on fait toutes les dérivations possibles de notre liste de mots prouvés pour obtenir une liste de mots prouvés plus grande.\n\nDeux approches coexistent alors, soit on fait toutes les dérivations possibles dans le sens direct, soit dans le sens indirect.\n\n\\subsection{La méthode bottom-up}\n\nOn part des $\\left\\{ [(b_1,[]);\\dots;(b_n,[])] \\mid (a,b)\\in D \\text{ et } b \\in T^\\star , n = \\norm{b}\\right\\}$ et on construit d\'autres arbres de dérivation à partir des règles de dérivation.\n\nPar la méthode bottom-up, on générerait dans l\'ordre :\\\\\nà l\'étape 0 :\n \\input{figures/tbu0.tikz}\nà l\'étape 1 : \n \\input{figures/tbu1.tikz}\nà l\'étape 2 : \n \\input{figures/tbu2.tikz}\nà l\'étape 3 : \n \\input{figures/tbu3.tikz}\n\nOn prouve par induction simple qu\'à l\'étape $k$, on a généré tous les arbres de dérivations possibles de profondeur $k$.\n\n\\subsection{La méthode top-down}\n\nOn part de l\'axiome $S$ de la grammaire non contextuelle pour construire des mots de $\\delta(S)$ en remplaçant un nonterminal $x$ d\'un mot par un $b$ d\'une règle de dérivation $(x,b)$.\n\nCette méthode suit d\'assez près la définition des mots de la grammaire non contextuelle\\\\\n(on peut écrire la clôture transitive et réflexive $\\overset{*}{\\rightarrow}$ comme :\n$\\overset{*}{\\rightarrow} = \\bigcup_{n \\in \\mathbb{N}} \\rightarrow ^n$, avec le produit usuel de deux relation binaires $\\forall \\mathcal{R}, \\mathcal{R}\' \\in X^2, \\mathcal{R} \\mathcal{R\'} := \\{(x,z) \\in X^2 \\mid \\exists y \\in X / (x,y) \\in \\mathcal{R} \\text{ et } (y,z) \\in \\mathcal{R}\'\\} $).\\\\\nOn génère en effet, avec cette méthode, à la $n$-ième étape, $A_n = \\left\\{m \\in (N \\cup T)^\\star \\mid  S \\left(\\bigcup_{k \\in [1,n]} \\rightarrow^k\\right) m\\right\\}$.\nIl est alors simple de vérifier que tout mot du langage de la grammaire sera généré en temps fini par cette méthode.\n\nOn génère alors dans l\'ordre :\\\\\nà l\'étape 0 : $\\{S\\}$, \\\\\nà l\'étape 1 : $\\{S,SS+,SS*,\"N\"\\}$,\\\\\net à l\'étape 2 : $\\{S,SS+,SS*,\"N\",SS*S+,SSS*+,SSS+*,SS+S*,$ \\\\\n$\"N\"S+,S\"N\"+,\"N\"S*,S\"N\"*,\"C\",\"NC\"\\}$.\n\nCette méthode est bien plus proche de la définition et est directement applicable aux grammaire formelles.\n\n\\section{Pour une grammaire formelle}\n\nChercher automatiquement une preuve d\'appartenance d\'un mot à une grammaire non contextuelle se fait déjà très bien avec les automates à pile.\nNous allons ici nous intéresser plus spécifiquement aux grammaires formelles, et réutiliser notre méthode top-down.\nLa méthode s\'applique alors directement de la même manière.\nNous avons donc un algorithme qui permet théoriquement de prouver que n\'importe quel mot de la grammaire appartient bien à cette dernière.\nLe problème étant la complexité de ce dernier, qui fonctionne comme une machine non déterministe où on ne coupe pas les instances arrivant à un état puit.\nLa suite va donc consister à trouver, de manière heuristique ou non, des méthodes affirmant qu\'à partir d\'un mot $m$, on aura des difficultés à dériver en notre mot $m\'$ à prouver.\nAlors, nous allons arrêter les recherches de dérivations de S en $m\'$ qui passent par le mot $m$.\n\n\\subsection{Une nouvelle structure de données pour les preuves}\n\nNous ne disposons plus des forêts de dérivation. Alors nous pouvons nous restreindre à la définition d\'un mot qui dérive d\'un autre.\nOn va alors fournir, comme preuve, une liste de mots $m_1, \\dots, m_n$ tels que $\\forall i\\in [1,n-1], m_i \\rightarrow m_{i+1}$. \nPour ceci nous allons renseigner de quelle manière le mot $m_{i+1}$ dérive du mot $m_i$ par la règle de dérivation $(a,b)$, par exemple en fournissant les indices délimitant $a$ dans $m_i$, et $b$ le remplaçant.\nNous aboutissons alors à :\n\\begin{verbatim}\ntype \'e preuveformelle = (int*int*(\'e caractere list)) list\n\\end{verbatim}\n\nNous prendrons comme exemple la grammaire formelle $G = (T,N_t,S,D)$ où :\\\\\n$\nT = \\{a,b,c\\}\\\\\nN_t = \\{S,B\\}\\\\\nD = \\{(S,aBSc)_1,(S,abc)_2,(Ba,aB)_3,(Bb,bb)_4\\}\n$,\\\\\nalors $aabbcc$ est dans $\\mathcal{L}(G)$ car $S \\rightarrow_1 aBSc \\rightarrow_2 aBabcc \\rightarrow_3 aaBbcc \\rightarrow_4 aabbcc$.\\\\\nEn Ocaml :\n\\begin{verbatim}\nlet unepreuve = [(0,1,mot \"aBSc\"),(2,3,mot \"abc\"),(1,3,mot \"aB\"),(2,4,mot \"bb\")]\n\\end{verbatim}\n\n\\subsection{Vérifier une preuve dans une telle structure de données}\n\n\\begin{verbatim}\nlet verif_deriv p grf mot = \n    let i,j,m = p in\n    let achanger = soustrait i j mot in\n    List.mem (aechanger,m) grf.reglesf\n\nlet verif_preuve p grf = \n    let rec aux p mot = \n        match p with\n            |[] -> true\n            |t::q -> \n                let i,j,m = t in\n                (verif_deriv t grf) && (aux q (remplace i j mot))\n    in \n    aux p [grf.axiome]\n\n\\end{verbatim}\n\n\\subsection{Générer automatiquement les preuves}\n\nPour ce faire, pour dériver un mot $m$ en mot $m\'$, on calcule $S(x) := \\{x \\in (N\\cup T)^\\star \\mid m \\rightarrow x\\}$,\npuis, pour chaque $ y \\in S(x)$, on cherche une dérivation de $y$ en $m\'$.\n\nPour calculer $S(x)$, il suffit de faire une recherche de facteur.\n\nD\'où une implémentation en OCaml : \n\\begin{verbatim}\n\nlet succ x grf = \n    List.flatten\n    (\n        List.map \n        (fun (a,b) ->\n            let (i,j,u,v) = recherchefacteur x a in\n            (i,j,u@b@v)\n        )\n        grf.reglesf\n    )\n\nlet rec cherchederivation x m grf =\n    if x = m then (___) else\n    let success = succ x grf in \n    parcoursmagique cherchederivation success\n\\end{verbatim}\n\n{\\color{red} TODO :\\\\\\\\  FINIR CE CODE }\\\\\n$S(x):= \\{ubv \\in (N_t \\cup T)^\\star \\mid \\exists (a,b) \\in D / \\exists (u,v)\\in (N_t \\cup T)^\\star / x = uav\\}$\n\n\\section{Une première simplification : Les grammaire croissantes}\n\nUne grammaire croissante est une grammaire telle que :\n\\begin{equation}\\forall (a,b) \\in D, \\norm{a} \\leq \\norm{b} \\end{equation}\nOn a alors une première propriété très simple, $\\forall m, m\' \\in \\delta (S), m \\overset{*}{\\rightarrow} m\' \\implies \\norm{m} \\leq \\norm{m\'}$.\n\nAlors, dans la recherche de dérivations de S vers m, on peut supprimer les \"branches de recherches\" qui partent d\'un mot de longueur $> \\norm{m}$.\n\n\\section{Une idée générale de simplification, le coeur de ce TIPE}\nRappelons, le problème : étant donné un mot $m$ d\'une grammaire, comment le dériver en un mot $m\'$ ?\nPour tout $l \\in N\\cup N_t$, on va chercher un ensemble $q(l)$ qui majore $\\norm{\\delta(m)}_l$.\n\nAinsi, $m \\overset{*}{\\rightarrow} m\' \\implies \\norm{m\'}_l \\in q(l)$, la contraposée nous sera utile : \n\\begin{equation*}\n\\norm{m\'}_l \\notin q(l) \\implies  \\neg (m \\overset{*}{\\rightarrow} m\')\n\\end{equation*}\nCe qui pourra nous permettre de réduire notre champ de recherche.\nEn effet, \n\n\\fbox{si pour un mot $x \\in \\delta(m)$, $\\forall l \\in (T\\cup N_t), \\norm{\\delta(x)}_l \\cap q(l) = \\emptyset$,\n alors $m\' \\notin \\delta(x)$}.\n\nPour calculer $\\norm{\\delta(x)}_l \\cap q(l)$, nous allons utiliser un graphe semblable à un automate.\n\nLes sommets sont des états de $Q \\subset ({\\mathcal{P}(\\mathbb{N})})^{T\\cup N_t}$ tels que :\n\\begin{align*}\n    &\\forall q,q\' \\in Q, \\exists l \\in (T \\cup N_t) / q(l) \\cap q\'(l) = \\emptyset\\\\\n    \\text{ et }&\\forall m \\in \\delta(S), \\exists q \\in Q / \\forall l \\in (T \\cup N_t), \\norm{m}_l \\in q(l)\n\\end{align*}\n\nAinsi à tout mot $x \\in \\delta(S)$, on peut associer un unique état $q$ tel que $\\forall l \\in (N_t \\cup T), \\norm{x}_l \\in q(l)$\n\nLes arêtes du graphe sont les dérivation possibles d\'un famille majorante $q$ à une autre $q\'$.\n\\begin{equation*}\n    \\forall (q,q\') \\in Q^2, (q,q\') \\in A \\iff \\exists x,x\' \\in (N_t \\cup T )^\\star / x \\rightarrow x\' \\text{ et } \\forall l \\in N_t \\cup T, \\norm{x}_l \\in q(l) \\text{ et } \\norm{x\'}_l \\in q(l)\n\\end{equation*}\n\nAinsi, si $m$ correspond à un état $q$, et $m\'$ à un état $q\'$, alors $m \\overset{*}{\\rightarrow} m\' \\implies$ $q\'$ est accessible depuis $q$.\n\n\\subsection{Les états $q$ sous la forme $\\forall l \\in N_t \\cup T, q(l) \\in \\{\\{0\\},\\mathbb{N}^*\\}$}\nExemple avec la grammaire suivante :\nD = $\\{(S,abc)_0,(abc,ab)_1,(b,k)_2,(c,ak)_3,(kak,aa)_4,(a,aaa)_5\\}$\n\nLe graphe est le suivant :\n\n \\tikzfig{grosgraphe}\n\nEt voici ce à quoi correspondent les différents états (sommets) du graphe : \n\n \\input{figures/belletable}\n\nLe graphe réduit suivant sera utile : \n\n \\tikzfig{ptitgraphe}\n\nAinsi, nous pouvons tout de suite affirmer qu\'il est impossible de dériver aaabakab en akkcckaaakck (en effet, $\\psi$ n\'est pas accessible depuis $\\delta$)\n",end='')

print("\n\n\\end{document}\n    ",end='')
